package utils

import (
	"strconv"
	"strings"
)

// ScaleBarcodeData holds the extracted information from a smart scale barcode.
type ScaleBarcodeData struct {
	IsScaleBarcode  bool
	ItemID          string  // The 5-digit internal SKU/Identifier (e.g., "00123")
	CalculatedPrice float64 // The embedded exact price or weight value
}

// ParseEAN13 inspects a barcode string to see if it was generated by a deli/produce scale.
// If it is a scale barcode, it slices the string to extract the Item ID and the Value.
func ParseEAN13(barcode string) ScaleBarcodeData {
	// 1. Length Check: Standard EAN-13 barcodes must be exactly 13 digits.
	if len(barcode) != 13 {
		return ScaleBarcodeData{IsScaleBarcode: false}
	}

	// 2. Prefix Check: In-store commercial scales typically use prefixes 20 or 21.
	if strings.HasPrefix(barcode, "20") || strings.HasPrefix(barcode, "21") {

		// 3. Mathematical Slicing:
		// Index 0-1: Prefix (e.g., "20")
		// Index 2-6: Item ID (5 digits)
		// Index 7-11: Price/Weight Value (5 digits)
		// Index 12: Checksum (1 digit)
		itemID := barcode[2:7]
		valueStr := barcode[7:12]

		// 4. Value Conversion:
		// The scale encodes the value as an integer (e.g., "01550" represents RM 15.50).
		// We convert the string to an integer, then divide by 100 to get the float representation.
		valueInt, err := strconv.Atoi(valueStr)
		if err != nil {
			// If the value isn't a valid number, fail gracefully.
			return ScaleBarcodeData{IsScaleBarcode: false}
		}

		calculatedPrice := float64(valueInt) / 100.0

		// Return the successfully extracted data.
		return ScaleBarcodeData{
			IsScaleBarcode:  true,
			ItemID:          itemID,
			CalculatedPrice: calculatedPrice,
		}
	}

	// If it doesn't start with 20 or 21, it's just a regular pre-packaged product barcode.
	return ScaleBarcodeData{IsScaleBarcode: false}
}
